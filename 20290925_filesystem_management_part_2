Redirector operators
---------------------
Every bash command takes the input data (if any) from the STDIN (keyboard) and writes/generates the output onto STDOUT (console/monitor). If we want to change the input (STDIN) or output (STDOUT) of the bash commands then we need to use redirector operators.
	
There are 2 types of redirector operators are there
1. < = input redirector operator. to redirect the input for a bash command
2. > = output redirector operator. to redirect the output out of a bash command to a different destination other than STDOUT.
	
How to write an output message onto the STDOUT?
echo "message"	
the echo bash command takes an message as an input and writes that to the STDOUT. if we want to redirect the output generated by the echo to a different destination other than STDOUT then we can use ">" output redirector operator. 
	
for eg.. if we want to write the output generated by the above echo bash command into a file, then we can use output redirector as below

echo "message" > filename
echo "Good morning" > greetings

if the output file we specified here is an existing file with data, it will replace the contents of the file with new output that is being generated. Incase if the file we specified doesnt exist, it creates an new file by writing the content.
	
if we dont want to replace the contents of the existing file rather if we wish to append to the existing file data we need to use >> (append operator)	
	
echo " Sriman!" >> greetings

now the greetings file will be appended with "Sriman!"


2. How to create an file with data, by reading the data from the STDIN (interactively) from the user?
	
every linux bash command takes the input from the STDIN and writes the output to STDOUT
cat filename = takes the input from file we passed and writes the output to STDOUT


linux command takes the input from STDIN
cat filename = here already input redirection is happening, because cat is not taking the data from STDIN, rather it is taking from file we supplied

cat filename is equal to cat < filename
from this we can understand for any command if we are passing argument means we are using input redirection implicitly

so if we dont supply any filename as an input the cat takes the input from STDIN and writes the output to STDOUT
cat
now the cursor waits for input from the keyboard and writes the output to STDOUT until we press ctrl + d it keeps going.
	
How to create a file with data interactively?
cat > filename


How to copy the contents of one file into another file without using cp?
cat < file1 > file2

Using regular expressions within the bash commands
There are 3 characters we can use as expressions aspart of bash commands
1. * = for any character of any number match
2. ? = single character match
3. [] = given a range of characters within which a single character match

$HOME
|-products
	|-lg-32-led-television.txt
	|-lg-40-led-television.txt
	|-lg-55-4k-television.txt
	|-samsung-32-led-television.txt
	|-samsung-40-qled-television.txt
	|-samsung-55-qled-television.txt
	|-lg-75-oled-television.txt
	|-sony-bravia-32-lcd-television.txt
	|-boss-speakers.txt
	|-boss-7.1-home-theater.txt
	|-hytachi-7.1-home-theater.txt
	|-sony-5.1-home-theater.txt
	|-apple-15-pro-mobile.txt
	|-samsung-S23-ultra-mobile.txt
	|-google-pixel9-mobile.txt
	|-playstation5-gaming-console.txt
	|-xbox-x10-gaming-console.txt
	|-nintendo-switch-gaming-console.txt
	|-hp-pavilion-16inch-laptop.txt
	|-dell-inspiron15-laptop.txt
	|-apple-macbook15-laptop.txt
	|-dell-lattitude700-laptop.txt
	|-acer15-laptop.txt
	|-ibm-lenovo16-laptop.txt
	
	
1. How to see all the list of files and folders within the products/ directory?
ls -l products/
		
2. How to see all the files and folders inside the product/ directory manufactured by apple?
ls apple*		
		
3. How to see all the televisions of led type?
ls -l *led*-television.txt

4. Show all the products manufactured by any vendor whose brand name has "2" characters only?		
ls -l ??-*		

5. show me all the laptops that are manufactured by vendors whose name starts with "d" or "h"?
ls -l [hd]*-laptops.txt

6. remove all the laptops within the products/ directory?
rm *-laptop.txt

7. copy all sony products into sony/ sub-directory within the products?
~/products:/> mkdir sony
~/products:/> cp sony* sony/
	
8. move all the televisions into televisions/ sub-directory within the products?
~/products:/> mkdir televisions
~/products:/> mv *-television.txt television/
--------------------------------------------------------------------------------------------------------------------------

Working with ranges in bash commands
We want to execute a shell or bash command repeatedly over the range of arguments/inputs then we need to use ranges represented with {}

For eg.. we want to print 1 to 10 numbers onto the console, this can be done by using echo as below
echo 1
echo 2
echo 3
echo 4
echo 5
echo 6
echo 7	
echo 8
echo 9
echo 10
	
it is time taking and repeatitive in executing the same command only with different input/argument passed. The argument value is taking a range of values from 1 to 10, in this case instead of repeatedly writing the same echo command we can use ranges

echo {1..10}

We want to create dairy files for all the days within the month, for eg.. aug month 31 days we want to create dairy files with dairy-day1.txt dairy-day2.txt dairy-day3.txt ... dairy-day31.txt

touch dairy-day1.txt
touch dairy-day2.txt

mkdir aug
cd aug/
touch dairy-day{1..31}.txt

How to remove the dairy files between 20 to 29 days?
rm dairy-day{20..29}.txt

the ranges can be used on alphabets also as below:
echo {a..z}

there is an difference between [] and {}:
[] = group of inputs (choice of inputs) = within the group we are choosing one
{} = range of inputs 
-------------------------------------------------------------------------------------------------------------------------
Hidden files in Linux operating system?
In linux operating system, if we create a file/folder	starting with "." aspart of it, then linux treats the file/folder as hidden and will not be displayed when we use ls command.
	
touch .passwords = as this file starts with ".", it will be treated as an hidden file
mkdir .keys = considered as hidden directory

when we use ls command, these 2 file and folder will not be shown. incase if we want to see these hidden files we need to use -a switch in ls command (-a stands for all)
	
ls -la
-------------------------------------------------------------------------------------------------------------------------
working with more
When we are using linux bash commands, these commands produces the output upon execution, sometimes the output generated by these commands are pretty huge and will not fit onto the screen or terminal buffer and would automatically scrolled up.
	
Along with this the terminal buffer size is always limited and can hold only few lines of last generated output and previous output would be rollout-up (cleared) automatically

due to this we will not be able to read easily or scroll-up back into the previous lines of output generated by the bash command. If we want to see all the output of a command and scroll through it line by line we can use "more" utility with any bash command.
	
tree /
since we ran tree on "/" root of the filesystem, it generates huge amount of output and auto-scrolls the content we can use "more" for scrolling through lines easily

tree / | more

book.txt = inside this book.txt we have #1000 lines of story or content, when we use cat command the output generated by the cat will be rolled-up (cleared) automatically only by showing last few lines of output. we can use "more" here as well for scrolling through the output of cat as below

cat book.txt | more
-------------------------------------------------------------------------------------------------------------------------
head and tail commands
-----------------------
head and tail are the most popular and frequently used bash commands in scrolling throught the logs files while debugging, let us explore.
	
1. head
head is something similar to cat. The "cat" is used for seeing the contents of a File, similar to that head is also being used.
	
we have a file with huge content around #1000 lines or more inside it. if we use cat command it renders all the thousand lines leaving or taking us to the bottom of the terminal displaying last page of content only and few times we will not be able to scroll-up due to the terminal buffer size.
	
Instead if we are only interested in top few lines of the file, rather than all of the content of the file we can use head.
	
cat filename = renders the entire contents of the file

instead we can use head as below
head filename = only displays the top 10 lines by default as an output

if we want to see only specific number of lines from the top of the file we can use -n option as below
head -n filename 
for eg.. if we want to see only top 5 lines we can use
head -5 filename
-------------------------------------------------------------------------------------------------------------------------
2. tail
tail is also same as cat, means it is also used for seeing the contents of a file. But it is used for seeing only the latest or bottom lines of a file. Usually tail is used for accessing the log files that are generated by the applications.
	
tail filename = by default shows the bottom 10 lines within a file
tail -n filename = shows the specified n number of lines from the bottom of the file

What is logging within an Application?
An Software Application comprises of bunch of programs working together in providing the business services that are required for running the business.
	
A program contains lot of lines of code or instructions that are written by the programmers to perform some operation.
	
The developers while writing the programs, they will add log statements to generate intermediate output during the execution of the program. This intermediate output that is generated by the program while execution acts as an checkpoints or debug info for the developers to debug and identify the problems within the program. This process of generating the intermediate output while executing the program is called "Logging"
	
In a large programs/applications the amount of log output that is generated by the program is very huge. So at somepoint in time, the output generated and written on to the console will be vanished or cleanedup. So to have these log output being used as later point of time, the intermediate output are written onto a file which are called log files.
	
These log files are persisted permanently on the harddisk of the computer, so that developer can go back anytime to see the log output and debug the application

From the above, the log output generated by the programs are written into log files (persisted permanently). 
	
As the programs while running generates and writes the output into log file, the size of these log files will be very huge, when developer wants to debug, he will not be interested in entire logfile, rather he wanted to see the latest log output that is recently generated by the program to debug.
	
so how can the developer can only see the recent or latest log output generated by the programs in the log files?
he can use tail command with specific number of recent lines he wanted to see.
	
The tail has another option called -f. -f stands for flow of the file

There are programs that runs longer amout of time and keeps generating the log output and writes on to the log file. If developer wants to monitor the program execution and see the continous log output generated by the program during its execution, he can use -f option

tail -f out.log
this will allows us to stream/browse throught he live log output generated by the program into the out.log file.
	
write a shell program that generates a bunch of numbers and writes to an log file, so that we can	the live log output using -f option in tail command.
	
1. Inorder to write the shellscript program we use gedit (notepad in windows like) text editor as below
~/> gedit printNumbers.sh

#!/bin/bash
I=1
while [ $I -lt 200 ]
do
	echo $I >> /tmp/out.log
	I=$[I+1]
	sleep 1s
done

2. grant execute permission to the program
~/> chmod u+x printNumbers.sh

3. run the program
~/> ./printNumbers.sh

4. open a new tab in the console and use tail -f to view the live log generated by the program
/tmp:/> tail -f out.log

How to compare the contents of 2 different files?
The are 2 bash commands for comparing the contents of the files
1. cmp
2. diff

1. cmp
cmp stands for compare, it is used for comparing 2 files byte by byte and output the first different between the file contents

fruits.txt
apple
banana
papaya
grapes

fresh-fruits.txt
apple
banana
papaya
oranges
grapes

when we use cmp for comparing these 2 files it compares fruits.txt and fresh-fruits.txt byte by byte and shows the first difference between those 2 files
fruits.txt fresh-fruits.txt differ: 18 byte, line 5
	
if there is no difference between those 2 files, then it will not show any output.
	
1. cmp fruits.txt fresh-fruits.txt
fruits.txt fresh-fruits.txt differ: 18 byte, line 5
	
	
2. -b option
if we use -b option, it shows at what byte the difference has been found in the file

cmp -b fruits.txt fresh-fruits.txt
fruits.txt fresh-fruits.txt differ: 18 byte, line 5 g asciicode o asciicode

3. -i option
ignore the specified number of bytes starting from top in both the files while comparing
cmp -i 18 fruits.txt fresh-fruits.txt
fruits.txt fresh-fruits.txt differ: 3 byte, line 1

4. -i n1:n2
ignore starting from the top of the file n1 bytes in first file and n2 bytes in second file and compare
n1 = ignore n1 bytes in first file
n2 = ignore n2 bytes in second file
and begin comparing the files

cmp -i 18:20 fruits.txt fresh-fruits.txt


5. -l = list all the difference between both the files
cmp -l fruits.txt fresh-fruits.txt
byteposition line fruits.txt fresh-fruits.txt
...
..
..
--------------------------------------------------------------------------------------------------------------------------
2. diff
diff stands for difference, it is used for comparing the contents line by line within the given 2 files. Not only the diff command helps in comparing the contents it displays recommendations through special symbols indicating how to make the contents of the 2 files identical.
	
symbols:
1. a = add
2. c = change
3. d = delete
4. > = refers to the contents of the file2
5. < = refers to the contents of the file1

#1. add recommendation

groceries
-------------
chanadal
urdal
sugar

groceries_mustbuy
----------------------
chanadal
urdal
sugar
rice

diff groceries groceries_mustbuy
3a4
> rice

after the 3rd line in groceries add the 4th line of groceries_mustbuy and the 4th line is
> rice

#2. delete recommendation

fruits
-------
grapes
papaya
oranges
banana

fresh-fruits
------------
grapes
papaya
oranges

diff fruits fresh-fruits
4d3
< banana
delete the 4th line in fruits, so that from 3rd line onwards both the files becomes identical

#3. change recommendation

products
---------
sony 32inch led
iphone 15 pro
bose soundbar

warehouse-products
-------------------
sony 32inch led
iphone 15 pro
sony playstation5

diff products warehouse-products
3c3
< bose soundbar
----------------
> sony playstation5

change the 3rd line products with 3rd line in warehouse-products
the line to be changed in left-side file is bose soundbar and the line in right side is > sony playstation5

#4. multiple differences between the files (recommendations)
vegetables
----------
brinjal
tomato
chillies
onions
potatoes
beetroot
carrot
spinach
oil

shoppinglist
------------
brinjal
tomato
sugar
chillies
onions
curryleaf
beetroot
carrot
spinach


1. recommendation
diff vegetables shoppinglist
2a3
> sugar

2. recommendation
5c5
< potatoes
-----------
> curryleaf

3. recommendation
9d8
< oil
#1. man pages
--------------
In linux (or) bash interpreter, every command has plenty of options, it would be practically impossible to memorize all the options of each command to use it. So to help us in quickly browsing through the manual or documentation of a command linux has provided an utility called "man"
	
man command
man stands for manual and provides documentation about the command we asked.
-------------------------------------------------------------------------------------------------------------------------

#2. How to count the number of characters, words and lines in a given text/character file?
wc = word count

wc is an handy bash utility/command available for counting the number of characters, words and lines within the given text file. We can use switches in finding the counts as below

-l = line
-c = characters
-w = words

wc file1
by default shows the number of lines, words and characters within the given file
if we want we can individually gets the count of each of them using the options described above
--------------------------------------------------------------------------------------------------------------------------
#3. How to know the currently logged in user of the linux operating system?
whoami

whoami = shows the currently logged-in user of the linux operating system.
--------------------------------------------------------------------------------------------------------------------------
#4. How to find all the users who are currently logged-in into the linux operating system?
Linux is an multi-user operating system, and they can multiple users can parallely login and use the operating system of the computer
we can find all those list of users using

who
shows all the users and TTY of the users there are logged in
-------------------------------------------------------------------------------------------------------------------------
#5. 
Each user who wants to access the linux operating system must and should register by creating an user account. All the users information who are registered with linux will be stored by the operating system aspart of a file

/etc/passwd

/etc = it is the directory in which installed software package configuration files are stored.
/etc/passwd = can be accessed by only the super users only, so we need to use sudo command while accessing the file contents	

sudo cat /etc/passwd
--------------------------------------------------------------------------------------------------------------------------
#6. How to know the hostname or ip address of the computer?

hostname = is used for accessing the machine name of the computer
hostname -I = displays the ip addresses of all the network interface cards attached to the computer. 
	In-Short: ip address of the computer
	
#7. How to know the os version of the linux kernel?
uname -r = shows the linux kernel version we are on

The operating system name and version of it is stored aspart of /etc/os-releases file we can access this info using
sudo cat /etc/os-release

lsb_release -a = shows the operating system name and release version
lsb stands = linux stand base release

hostnamectl = used for querying and changing the hostname and related settings
-------------------------------------------------------------------------------------------------------------------------
#7. which shell interpreter are we using?
echo $0 = shows the name of the shell interpreter we are using

1. wc  = word count
2. man = manual pages
3. /etc/passwd = list of user accounts of the linux system
4. whoami = current logged-in user
5. who = all the users currently logged-in to the system
6. hostname (or) hostname -I = to know the name of the machine and its ip address
7. os version & name
	1. uname -r
	2. lsb_release -a
	3. cat /etc/os-release
	4. hostnamectl
8. echo $0 = shell we are currently using
--------------------------------------------------------------------------------------------------------------------------
Working with Pipe operators (Pipes)
-----------------------------------
Pipe(|)	

< & > = redirector operators. These are used for redirecting the output/input of an linux command from an different source or different destination other than STDIN and STDOUT respectively.

pipe is indicated by the symbol | is used for passing the output of an linux command as an input to another linux command. 
command1 | command2

when we join #2 commands with a pipe operator, always the command execution starts with left-most command (here command1), the output that is produced by the command1 will be passed as an input to the command2, performs operation and generates the output onto an STDOUT destination

In this way we can combine any number of commands together by using | operator
command1 | command2 | command3 | command4 ......
	
pipes is the most powerful feature of the linux bash interpreter, where we can recreate infinite number of linux command by joining the the commands using | operator.
	
	
1. How many users are currently logged-in into the Linux system?
who | wc -l

here the who returns list of logged-in users that is passed as an input to the wc asking him to count the number lines that are there within the output of who

2. how many user accounts are there within the linux system?
cat /etc/passwd | wc -l

3. How to see only the top 5 files/directories within the given directory?
ls -l | head -5	
	
4. How to retrieve top 3 ranks within the given file?
rank
-----
10
20
97
94
93
100
38
92

cat rank | sort -gr | head -3
1. cat = output the contents of the rank file 
2. sort = takes the output of the cat command as an input, does a nuemaric sort (-g) and writes the output in reverse order (-r) 
3. head takes the output of sort as an input and displays only top 3 lines

5. Find the count of words within the 1st line of a File
story
------
Have you sailed to the island of Bum Bum Ba Loo?
Itâ€™s something that all great explorers must do
Ten years ago, I set off with my crew
In search of the island of Bum Bum Ba Loo
The waves on the sea made me wish that I flew
To get to that island of Bum Bum Ba Loo

head -1 story |wc -w

6. Sort and List the Files and Directories based on the Size of the Files?
ls -l = shows all the files and folders within the current directory along with their size
sort -g = nuemaric sort -k based on specific column within the input

ls -l | sort -gk 5

find command
-------------
find is one of the powerful and repeatedly used shell command. It is used for searching the files or folders of the Filesystem of the computer matching with Names. By using find we can search for files or folders by name including the sub-directories also

~/movies (10000: collection)
	|-action
		|-golden-eye.mkv
		|-taken
		|-johnwick
	|-adventure
		|-journey
		|-journey2
		|-castaway
		|-indianajones
	|-comedy
		|-friends
		|-deadpool
		|-badboys
		|-dumb-and-dumbers
	|-thriller
		|-the-mask
		|-joker
		|-hush
		|-aliens
	|-horror
		|-anabelle
		|-nun
		|-nun2
		|-conjuring
		|-exorcist
		|-evil-dead

we want to find an movie within the movies/ or any of the sub-directories, inorder to do this, we need to manually navigate into movie/ directory and all of the sub-directories under it to locate and access an movie we are looking for. But this process of manually looking up/searching through for a movie is time taking process and might endup in failure in locating the file because of human error


instead of we manually navigating through the directories for searching for the file, we can make use of "find" bash command.
"find" = is used for searching for a file or folder with a given name

find directory/ -name "filename"
directory/ = refers to the directory in which we wanted to search for the file with given name -name "filename"
		
~/> find movies/ -name "nun"

There are plenty of options in using the find are available:

1. find directory/ -name "pattern"
it search for the file matching with filename of the given "pattern" under the specified directory/ including the sub-directories and displays the list of matching filenames along with their path one per each line


2. find directory/ -name "pattern" -print = displays each matching outcome in a new line. default option

3. find directory/ -name "pattern" -print0 = print or display all the matching outcomes in one-single line

4. find directory/ -type f -name "pattern"
-type f = stands for find only files matching with pattern, ignore directories
-type d = only match directories and ignore files

5. find directory/ -name "pattern" -empty
returns all the empty files or folders of the given matching pattern

6. how to search for files/folders of multi-pattern matching
list down the file/folder names matching with either pattern1 or pattern2

find directory/ -name "pattern1"
find directory/ -name "pattern2"
	
this will result in @2 list of outputs, rather we want combined output of the files of any matching pattern1 or pattern2

find directory -name "pattern1" -o -name "pattern2"
	
7. How to perform an action or an operation on the outcome of the find command?
we can use find with -exec option to perform an operation on the each outcome returned by the find command.
	
syntax:
find directory/ -name "pattern" -exec command {} \;


	
find movies/ -type d -name "a*" -exec ls {} \;
action/
adventure/
find
find is used for searching for files and folders within the given directory matching with the pattern provided.
	
1. find directory/ -name "pattern"
2. find directory/ -name "pattern" -print (default)
3. find directory/ -name "pattern" -print0
4. find directory/ -name "pattern" -empty
5. find directory/ -type f|d -name "pattern"
6. find directory/ -name "pattern1"	-o -name "pattern2"
7. find directory/ -name "pattern" -exec command {} \;
--------------------------------------------------------------------------------------------------------------------------
	
grep (content-based searching)
------------------------------
find is used for searching for files/folders matching with their name with given pattern, whereas grep is used for content based searching which means we want to find files(only) whose content is matching with given phrase or text

~/ledgers
	|-customer1-ledger
	|-customer2-ledger
	|-customer3-ledger
	|-customer4-ledger
	|-customer5-ledger
	
in each the ledger files we are storing financial entries of the customers along with their bank accounts. we want to search for the ledger files who holds/carries the financial transactions of a specific bank account no, how can we do this?
	
we need to goto each customer*-ledger file, open the contents of it, read to see whether the file contains the bank account no we are looking for. if there are just 2/3 files we can quickly look into them by opening each of them, but we have to find over a bunch of files, it would be very difficult job and endup in spending huge time and might lead to failure in identifying the files as well.
	
To help us in quickly searching for the files whose content is matching with given text: grep bash command has been provided.
	
It is an powerful utility used very frequently in searching through the log files for a given "log message" or "for an error".
	
There are plenty of options are available in grep:
1. grep "text" filename = it displays all the matching lines of the text specified.
	
2. grep -R "text" directory/
search within the given directory including the sub-directories recursively to find the files that contains the "text" content. If found display the matching lines where the text was found along with filename.
	
3. grep -R -n "text" directory/
-n print the line number where the text content was found in that file

4. by default grep search for the given text within the file matching with case, if we want to search with ignore case we can use -i switch or option as below

grep -i "text" filename
grep -Ri "text" directory/
	
5. 	grep -w "text" filename 
by default grep performs partial matching and returns the content. Incase if we wanted to only perform whole word matching then use -w

6. grep -o "text" filename
-o indicates print only the matching words, dont print the matching lines

7. grep -c "text" filename
-c = indicates count of matching text within the file

Below options are very useful when we are browsing or accessing log files for exceptions/errors and information messages.

8. grep -digit "text" filename
for eg.. grep -2 "text" filename
print along with matching lines, 2 lines above and 2 lines below as well

9. grep -Adigit "text" filename
print along with matching lines, digit number of lines after the matching line as well

10. grep -Bdigit "text" filename
print along with matching lines, digit number of lines before the matching line as well

11. grep -v "text" filename
-v = stands for inverted match. print all the lines that doesnt have these matching text

grep allows us to use regular expressions also aspart of the text phrase we are searching for, for more complex searches as below:
1. [] = any one of the single character match within the group
2. [1-10] = matches one character within the given range of characters

3. ^ = this pattern must appear at the begining of the line
ls -l | grep ^d = show me only the directories within the current directory

4. . = matches with any one character

5. $ = this pattern must match at the end of the line
ls -l | grep .sh$ = show me only the shellscripting files within the current directory

6. \ = escape character

7. * = occurence of a pattern zero or once
8. .* = nothing or any number of matches

1. list all the contents of a directory other than directories
ls -l | grep -v ^d
grep:
1. grep "text" filename
2. grep -R "text" directory/
3. grep -i "text" filename
4. grep -n "text" filename
5. grep -o "text" filename
6. grep -w "text" filename
7. grep -c "text" filename
8. grep -v "text" filename 
9. grep -digit "text" filename
10. grep -Adigit "text" filename
11. grep -Bdigit "text" filename

regular expression:
[] = single character match within the group of characters
[1-10] = single character match within the range specified
^ = starts with
$ = ends with
. = any single character
* = minimum one and can have repeated pattern
.* = any characters for any number of times
\ = escape character
--------------------------------------------------------------------------------------------------------------------------
text editors

Text Editors are used for creating new files or modifying existing files or viewing the contents of a file. In Linux operating system there are 2 types of text editors are there

1. gui
In ubuntu distro, the gedit is the default text editor that will be shipped and can be used for editing/viewing the file contents. In addition we can install any third-party gui text editors in the market like
	1.1 atom
	1.2 sublime text editor
	1.3 vs code
	etc
	
how to install vscode editor?
1. download the .deb file of the vscode editor to the ~/Downloads directory
2. cd ~/Downloads
3. sudo apt update -y
4. sudo apt install -f ./codeXXXX.deb	
	
The same process we can follow installing the atom or any text editor.
	
2. non-gui
Majority of the times linux operating system is being used in headless mode (no gui), hence any of the above gui based text editors will not be available. So linux operating system has provided non-gui text editors to help us in editing or creating or viewing the contents of the files in CLI Mode. 
There are several non-gui text editors are available aspart of the linux distros. out of various text editors available, there are #2 popular text editors widely used in the linux operating system world (across any distros)
	1. vi
	2. nano
	
1. vi
The most popular and default available text editor in majority of the linux distros is "vi" text editor. vi stands for visual editor and a more improved version of the vi editor is vim (stands for vi improved). it has more options than the vi editor.
	
vi is the classic text editor and is not much user friendly, so a improved version on top of the vi editor has been built with more options which is "vim" editor and is much user friendly.
	
Majority of the linux distros doesnt provide vim editor, rather ships vi editor only. So inorder to use vim editor we need to explicitly install it by using the below command

sudo apt update -y
sudo apt install -y vim

How to use vi/vim editor?
In vi or vim editor there are 3 modes are there
1. command mode
2. input mode
3. exit mode

1. command mode
upon opening the vi or vim text editor, by default it enters into command mode only. Within the command mode any keypress on the keyboard will not key-in the letter into the file, rather would be considered as a command and performs relevant operation on the contents of the file.
	
yy = copy the current line
p = paste 
o = open an newline below the current cursor position

in this way each letter on the keyboard is associated with an relevant operation and would be carried on the contents of the file when we are in "command-mode".
At anypoint we can return back to the command mode by pressing "esc" key on the keyboard

2. input mode
In the input mode we can write the data onto the file by typing the keys on the keyboard. To enter into the input mode we need to press "i" key on the keyboard from command-mode.
	
In vim editor it is called "insert" mode. 
	
Incase of vi editor:
when we are in input mode, we cannot move the cursor across the contents of the file by using arrow keys. the arrow keys are also taken as a input and inserts ascii equivalent data for those keys into the file so to move the cursor across the contents of the file, we need to mandatorily goback to command mode and use commands to move the cursor, thus causing a great level of in-convienience to the use and hence considered as non-user friendly editor

Incase of vim editor, even when we are in insert mode, we can still move the cursor across the contents of the file by using the arrow keys

3. exit mode
after entering the data into file, either we can save the contents of the file or dis-card the changes and can quit from the editor by going into exit mode

To enter into exit mode, we need to goback to command mode by pressing esc key on the keyboard. Then press ":" on the keyboard, thus enters into exit mode
here we have few options available
1. w + enter = write/save the content
2. q + enter = quit
3. wq+ enter = write and quit
4. q!+ enter = quit without saving the contents

--------------------------------------------------------------------------------------------------------------------------
1. we can open the editor with a new file by using
vi filename

this will creates an blank file under the current working directory. unless we write and quit the file will not appear or saved on the harddisk.
	
What are the commands available aspart of the command mode in vi/vim editor?
1. A = append the data at the end of the current line
2. a = append the data at the right-side of the cursor position
3. I = insert the data at the begining of the current line
4. i = insert the data in the current cursor position
5. O = open a new line above the current cursor position
6. o = open a new line below the current cursor position
7. r = replace a single character at the current cursor position
8. R = replace the text from the current cursor position
9. S = replace the current line
10. yy = yanking (copy the line)
	  2yy, 3yy, nyy = copy specified number of lines from the current cursor position
		
11. p = paste
12. x = delete a character at the current cursor position
13. dw = delete a word
14. dd = delete a line (2dd, 3dd, 4dd, ndd)
15. u = undo the previous action
16. b = back to the begining of the current word
17. w = beginging of the next word
18. e = end of the current word
19. :linenumber = jump to the specified line inthe file
20. G = goto the end of the file
21. ctrl + f = page forward
22. ctrl + b = page backward

23. how to search for an text within a file when we are using vi/vim editor?
1. goto command mode
2. /phrase + enter = to search for the given text phrase in the file
upon pressing enter key, it shows the first matching text occurence within the file. To find the next matching press "n" key and to show previous matches press "shift + n"
--------------------------------------------------------------------------------------------------------------------------
nano text editor

nano is another text editor that is popularly being used aspart of the linux operating system as an non-gui editor. unlike the vi/vim being programmers editor that needs to memorize lot of commands in using it, nano is an simple text editor that provides easy commands for editing the contents of an text file

nano is not available aspart of all the linux distros by default, we need to explicitly install, but in Ubuntu distro along with vi the nano is also provided by default.
	
How to use nano editor?
1. nano filename
if there exist already a file with that name, it opens up for editing the file, otherwise creates an blank file for writing.
	
2. ctrl + o (enter key) = writes the unsaved changes onto the file
3. ctrl + x (enter) = quit if there are any unsaved changes it asks for do you want to save or not (y/n)
4. ctrl + w = search for a word in the file
5. ctrl + \ = to replace a text phrase with different 
6. ctrl + k = cut the line
7. ctrl + u = paste the line
8. ctrl + c = displays the line number, characters within the file
9. ctrl + / = goto a specified linenumber
10. alt + e = redo
11. alt + u = undo
12. alt + a = goto selection mode to mark the content
13. alt + 6 = copy the selected content
---------------------------------------------------------------------------------------------------------------------------
Compression and Packaging
-------------------------
1. Packaging
We can package a directory of contents or bunch of files into one single file, so that it will be easily distributable over the network or through email. Packaging doesnt refers to compression, upon packaging the directory of contents or bunch of files, the original size of the contents willnot be reduced.

From this we can understand packaging means we are combining multiple files or directories into one-single file, so that it can be transferred easily.	
Linux has provided an utility called "tar" used for packaging a directory or bunch of files.
		
tar = stands for tape archieve
options:
1. -c = create
2. -v = verbose
3. -f = filename
4. -x = extract
5. -t = table of contents

1. How to package the files using tar?
when we package the contents of a directory or bunch of files, we generate a packaged file of extension ".tar" indicating it is an packaged file.
	
tar -cvf filename.tar directory/
tar -cvf filename.tar file1 file2 file3

2. How to extract the tar file?
tar -xvf filename.tar

3. How to see the contents of the tar file?
tar -tvf filename.tar
--------------------------------------------------------------------------------------------------------------------------
2. Compression
If we want to compress or reduce the size of the contents, then we need to use compression. Linux has provided #2 utilities gzip/gunzip which are used for compression and un-compression of the contents. In Linux we cannot directly compress and un-compress the bunch of files/directory, first we need to package the files/directory into one-single file, then only we can compress the contents of it. 
	
Similarly when we uncompress, the contents will not be produced as outcome, rather packaged file will be resulted, then unpack the file to restore the contents back.
	
For eg.. if we have a directory images/ with files as below
1.jpeg
2.jpeg
3.jpeg
4.jpeg
..
we cannot compress either directory/files directly, first we need to package them into a tar file, then we need to pass it as an input to the gzip to compress it 

1. package into one-single packaged file
tar -cvf images.tar images/
	
2. compress the contents of the tar file as below
gzip images.tar
the gzip compresses the .tar file and generates .tar.gz file onto the filesystem (the original tar will not exists)

how to compress and get the contents back?	
first uncompress and produce .tar file first from .tar.gz

gunzip images.tar.gz
this will produce images.tar

tar -xvf images.tar
will generates images/ directory back


From the above we can see that compression is an #2 step process of packaging and compressing or uncompress and unpack. Instead of doing this in #2 step we can perform compression in @1 single step itself using -z option aspart of tar utility as below

tar -czvf filename.tar.gz directory = -z option indicates (zip) compress the contents while packaging
tar -xzvf filename.tar.gz = uncompress and unpack
--------------------------------------------------------------------------------------------------------------------------
tr
---
tr is used for performing #3 types of operations on a text content
1. replace a single character in a given text
2. we can delete a single character in a given text
3. we can apply transformations on the entire text content passed as an input

1. replace a single character in a given text
echo "Linux is great!" | tr "x" "s"

the above tr command replaces "x" letter with "s" letter and generates the Linus is great!. It searches for all the occurences of "x" in the given text and replaces with "s".
	
echo "Humpty Dumpty sat on a wall!" | tr "m" "n" = Hunpty Dunpty sat on a wall!

2. delete a single character in a given text
echo "Good morning!" | tr -d o
it finds all the "o" in the given text and removes them from it

output: Gd mrning!

3. transform entire text content passed as an input
There are lot of built-in transformations are availble with tr
1. :upper:
2. :lower:
3. :space:
4. :digit:
5. :alnum:

echo "Linux operating system is highly portable" | tr "[:lower:]" "[:upper:]" 
echo "Math is complex" | tr "[:space:]" _ = Math_is_complex
echo "Matrix2" | tr "[:digit:]" 3 = Matrix3
echo "Pa3swor#2" | tr "[:alnum:]" "*" = *********
--------------------------------------------------------------------------------------------------------------------------


